# Threejs

https://github.com/pmndrs/react-three-fiber
https://github.com/pmndrs/drei

https://codesandbox.io/s/l4klb
https://codesandbox.io/s/9m4tpc
https://codesandbox.io/s/9s2wd9
код https://codesandbox.io/s/lx2h8

#

test@example.com
secret

#

cfeest@example.net
bebert@example.net
irwin.roberts@example.com
oconner.ahmed@example.org

password
# server 
docker exec -it php8 bash
cd ./filestorage/src && php artisan serve --host=0.0.0.0 --port=8005

# template

https://tailblocks.org/navigation1

## blog

https://github.com/davidgrzyb/tailwind-blog-template/blob/master/blog.html

### git

https://github.com/search?q=tailwind+blog+template+language%3AHTML&type=repositories&l=HTML&p=2

https://github.com/elhakimyasya/Webium-Blogger-Theme/tree/dev
https://github.com/yelocode/tailwind-css-blog/tree/main

# export to zip

https://stackblitz.com/edit/angular-grapejs-uixpcu?file=src%2Fapp%2Fapp.component.ts

#

https://codedexterous.medium.com/second-story-customize-grapesjs-editor-bbe2d91f5208

#

https://github.khronos.org/glTF-Sample-Viewer-Release/assets/models/Models/DamagedHelmet/glTF/DamagedHelmet.gltf

# TOAST

https://fkhadra.github.io/react-toastify/api/toast
//shortcut to different types
toast.success("Hello", options);
toast.info("World", options);
toast.warn(MyComponent, options);
toast.error("Error", options);

###

https://fontawesome.com/search?q=shot&o=r&m=free
https://gjs.market/

https://esketchers.com/building-custom-blocks-in-grapesjs-dynamically/
https://www.valuebound.com/resources/blog/how-show-grapesjs-editor-content-pdf

### php

https://copyprogramming.com/howto/grapesjs-hide-toolbar-and-show-component-code-example

### react block

https://codesandbox.io/p/sandbox/my-app-yqn8sj?file=%2Fsrc%2FWebBuilder.js
https://codesandbox.io/p/sandbox/grapes-nypnyt?file=%2Fsrc%2FChart%2Factions.js
https://github.com/code-dexterous/grapesjs-example-react/tree/main
https://doc.oroinc.com/bundles/commerce/CMSBundle/

https://github.com/GrapesJS/tui-image-editor/blob/master/README.md
https://gjs.market/products/grapesjs-cloudinary
https://github.com/Ju99ernaut/grapesjs-blockly
https://gjs.market/products/grapesjs-links-for-multipage-websites

###

https://www.valuebound.com/resources/blog/how-show-grapesjs-editor-content-pdf

## css template

https://w3schoolsua.github.io/css/css_website_layout.html#gsc.tab=0

## tailwind block

https://github.com/Ju99ernaut/grapesjs-tailwind/tree/master/src/blocks

## налаштувань та властивостей, які можуть бути використані для детального кастомізування компонентів і їх поведінки. Ось деякі з них:

draggable: true/false - Визначає, чи може компонент бути перетягнутий. Ви можете вказати конкретні селектори або елементи, в які можна перетягувати компонент.

 <div class="row-cell" data-gjs-draggable="false" name="column-row-3" type="column"></div>
droppable: true/false - Визначає, в які місця можна вставляти (або "капати") компонент. Це також може бути налаштовано як селектори або конкретні елементи.
layerable: true/false - Визначає, чи буде компонент показуватися у панелі шарів (layers panel). Це дозволяє користувачам бачити структуру свого проекту в ієрархічному вигляді.
stylable: true/false - Вказує, чи можуть бути змінені CSS стилі компонента через панель стилів. Можливість редагувати стилі дозволяє користувачам налаштовувати вигляд компонентів.
propagate: [...] - Дозволяє налаштувати, які властивості будуть наслідуватися дочірніми компонентами. Це корисно для уніфікації поведінки або стилів у комплексних компонентах.
script: function - Можливість призначити JavaScript функцію, яка виконуватиметься при рендері компонента. Це дозволяє додавати інтерактивність або специфічну логіку до компонентів.
traits: [...] - Визначає властивості (traits), які можуть бути редаговані через панель властивостей. Це дозволяє користувачам налаштовувати компоненти за допомогою графічного інтерфейсу без необхідності редагувати код.
content: [...] - Встановлює вміст компонента, який може бути статичним текстом, HTML або іншим компонентом.
content: "Click me", // Текст кнопки за замовчуванням
attributes: { type: "button" }, // Атрибути HTML тегу кнопки
badgable: true – Дозволяє компоненту показувати бейджі (маленькі попапи з інформацією) в редакторі. Це може бути корисно для відображення додаткової інформації про компонент при наведенні курсору або при виборі компонента.
highlightable: true – Дозволяє компоненту бути виділеним при наведенні курсору миші або при виборі. Це допомагає користувачам візуально ідентифікувати, над яким компонентом вони працюють.
selectable: true – Дозволяє компоненту бути вибраним при кліку. Вибрані компоненти можуть бути модифіковані через панель властивостей або переміщені в межах редактора.
data-gjs-selectable="false"
copyable: true – Дає змогу компоненту бути скопійованим. Це означає, що користувачі можуть дублювати компонент в рамках свого проекту.
resizable: true – Дозволяє змінювати розмір компонента в редакторі. Користувачі можуть вручну змінювати розміри компонента, перетягуючи його краї.
editable: true – Надає можливість редагувати вміст компонента безпосередньо у редакторі. Наприклад, для текстових компонентів це дозволить користувачам змінювати текст без відкриття модального або бокового вікна.
hoverable: true – Дозволяє компоненту реагувати на наведення курсору миші. Це може використовуватись для візуального відзначення компонента, над яким знаходиться курсор, надаючи користувачеві відчуття взаємодії.

## Content в editor.BlockManager

Якщо тре додати з тегом

```javascript
content: [{ type: "button" }, `<div>Extra</div>`] as any
```

якщо просто додати текст

```javascript
content: {
        type: 'text-component',
        content: 'Sample text content' // Вказуємо текст, який буде в компоненті за замовчуванням
}
```

## Pages

https://codepen.io/abhi_punk81/pen/MWbWzaq
https://grapesjs.com/docs/modules/Pages.html#initialization
https://grapesjs.com/docs/api/editor.html

```javascript
const editorJson = JSON.stringify(editor.getComponents().toJSON(), null, 2);
const stylesJson = editor.getStyle();
const cssContent = editor.getCss();
const htmlJson = editor.getHtml();
const pagesr = editor.Pages;
// Get an array of all pages
const allPages = pagesr.getAll();
// Get currently selected page
const selectedPage = pagesr.getSelected();
const pagesr = editor.Pages;
// Get an array of all pages
// const allPages = pagesr.getAll();
// Get currently selected page
const selectedPage = pagesr.getSelected();
const allPages = editor.Pages.getAll();
const htmlAll = allPages.map((p) => p.getMainComponent().toHTML());
const jsonAll = selectedPage.collection.map((p) => p.getMainComponent().toJSON());
console.log('selectedPagemodels', JSON.stringify(selectedPage.collection.models, null, 2));
```

## traits

init() {
this.on('change:href', this.updateHref); //ініціалізувати по події встановлення
},

this.setStyle({ color: 'red' }); //встановити стилі
// Оновити атрибут href елемента
this.addAttributes({ href: value });
this.addAttributes({ href: this.get('href') });

## model

this.model.addAttributes({ isThead: selectRows.value });//вставновлюємо як аргумент атрибуту
this.model.set("isThead", inputColumns.value);// встановлюємо як аргумент

### Editor Dictation by Voice

### Приклади для додаткових модулів

#### генерація SVG

https://codepen.io/kadmy/pen/gxgboo

#### генерація tooltip

http://www.menucool.com/tooltip/css-tooltip

## Maybe you can append it in head of iframe.

var iframe = editor.Canvas.getFrameEl();
iframe.contentDocument.head.appendChild(/_ your link tag here _/);

## Maybe you can append it in head of component.

editor.getComponents().add('<link rel="stylesheet" href="...">');

Хуки життєвого циклу:
Кожен компонент запускає різні перехоплювачі життєвого циклу, які дозволяють прослуховувати певні події та виконувати дію на різних етапах. Є два типи хуків: локальні та глобальні. Ви повинні визначити локальні хуки під час створення компонентів, і глобальні хуки будуть викликані для будь-якого компонента через editor.on.

Локальний хук – це model.init(), view.init(), що виконується після ініціалізації компонента
Локальний view.init(метод hook:), який виконується після ініціалізації перегляду компонента
Локальний хук: view.onRender()метод, який виконується після відтворення компонента на полотні
Глобальні хуки компонент:create, component:update
якщо вам не потрібно, щоб цей компонент був доступним для вибору, ви можете скористатися selectableвластивістю<div data-gjs-selectable="false">...

### test

https://github.com/GrapesJS/grapesjs/blob/ae1950761e277ae1c913b3a6a117127ff3019851/test/specs/grapesjs/headless.js

### режим дизайнера

Щоб запустити редактор, глобально в одному з режимів перетягування, вам слід змінити параметр моделі редактора.
const editor = grapesjs.init({
// ...
dragMode: 'absolute', // 'absolute' | 'translate'
});
// ... or to change via API

## для конкретного елемента

editor.setDragMode('absolute');
editor.getModel().set('dmode', 'absolute');

## API режиму перетягування

config.dragMode— Початкова конфігурація для режиму глобального перетягування
editor.setDragMode- змінити режим глобального перетягування компонентів
component.setDragMode- змінити режим перетягування окремого компонента
Possible values are already described: none (default), absolute, translate
editor.getModel().set('dmode', 'absolute');

## отримати iframe #Document

editor.Canvas.getDocument()

## editor find

        const changedAttributes = component.changedAttributes();
        const componentChange = component.getAttributes()['data-type'];
        const components = editor.DomComponents.getWrapper().components();
        const wrapper = editor.DomComponents.getWrapper();
        const wrapperElement = wrapper.getEl();
        const compById = editor.getWrapper().find('[data-type]')
        // Now you can use querySelectorAll on the DOM element
        const elements = wrapperElement.querySelectorAll('[data-type]');
        const component = editor.getSelected();

## отримати всі ідентифікатори ParentI/child

editor.Canvas.getDocument().body.querySelectorAll("[id]")

## events listenTo

this.listenTo(this, 'change:content', this.handlePropChange1); при зміні контенту
this.listenTo(this, "change:attributes:isThead", this.changeIsThead);
this.on('change:attributes:isThead', this.changeIsThead);

## events editor.on

editor.on('component:selected', this.handlePropChange); при виборі компонента
editor.on('component:styleUpdate', this.handlePropChange); при зміні стилю любого компонента
Доступні події
component:create- Компонент створюється (тільки модель, ще не змонтована в canvas), викликається після методу init().
component:mount- Компонент монтується до елемента та відображається на полотні
component:add- Запускається, коли новий компонент додається до редактора, модель передається як аргумент зворотного виклику
component:remove- Запускається, коли компонент видаляється, модель передається як аргумент зворотного виклику
component:remove:before- Запускається перед видаленням компонента, модель, функція видалення (якщо перервано через параметри, за допомогою цієї функції ви можете завершити видалення) і параметри (використовуйте options.abort = true, щоб запобігти видаленню), передаються як аргументи зворотного виклику
component:clone- Запускається, коли компонент клонується, нова модель передається як аргумент зворотного виклику
component:update- Запускається, коли компонент оновлюється (переміщується, стилізується тощо), модель передається як аргумент для зворотного виклику
component:update:{propertyName}- Прослуховування будь-якої зміни властивості, модель передається як аргумент зворотного виклику
component:styleUpdate- Запускається, коли стиль компонента оновлюється, модель передається як аргумент зворотного виклику
component:styleUpdate:{propertyName}- Слухайте певну зміну властивості стилю, модель передається як аргумент зворотного виклику
component:selected- Вибрано новий компонент, вибрана модель передається як аргумент зворотного виклику
component:deselected- Компонент скасовано, модель, яку скасовано, передається як аргумент зворотного виклику
component:toggled— Вибір компонентів змінено, переключена модель передається як аргумент зворотного виклику
component:type:add— Додано новий тип компонента, новий тип передається як аргумент зворотного виклику
component:type:update— Тип компонента оновлено, оновлений тип передається як аргумент зворотного виклику
component:drag:start- Розпочато перетягування компонентів. Передано об’єкт зворотному виклику, що містить target(компонент для перетягування), parent(батьківський елемент компонента) та index(індекс компонента в батьківському)
component:drag- Під час перетягування компонента. Передається той самий об’єкт, що й у component:drag:startподії, але в цьому випадку parentвін indexоновлюється поточним вказівником
component:drag:end- Перетягування компонента завершено. Передається той самий об’єкт, що й у component:drag:startподії, але в цьому випадку parentвін indexоновлюється кінцевим покажчиком
component:resize- Під час зміни розміру компонента.

# update components in model

if (!components.length) {
components.add([allProducts + '<style></style>');
} else {
this.components(allProducts);
}

## Get editor

### getContainer

(window as any).editor.getContainer()
Повертає елемент контейнера. Той, який було вказано як «контейнер» у методі ініціалізації

Повертає HTMLElement
Вставте HTML у полотно за допомогою команди.

## editor.Canvas.getBody().ownerDocument.execCommand('insertHTML', false, HTMLString)

вставлений HTML дійсно відображається на полотні редактора.
Використовуйте функцію editor.getHtml() редактора.
Повернений рядок HTML editor.getHtml()не містить HTML, який було вставлено за допомогою команди execCommand.

## Get editor.Canvas

https://grapesjs.com/docs/api/canvas.html#getdocument
(window as any).editor.Canvas.getDocument()

### getConfig

Отримати об'єкт конфігурації
Повертає Object(відкриється нове вікно)

### getElement

Отримайте елемент canvas
Повертає HTMLElement(відкриється нове вікно)

### getFrameEl

Отримайте основний каркасний елемент полотна
Повертає HTMLIFrameElement(відкриється нове вікно)

### getWindow

Отримайте екземпляр вікна головного фрейму
Вікно повернення(відкриється нове вікно)

### getDocument

Отримайте елемент основного кадру документа
Повертає HTMLDocument

### getBody

Отримайте основний каркасний елемент body
Повертає HTMLBodyElement(відкриється нове вікно)

### Zoom

canvas.setZoom(50); // set zoom to 50%
const zoom = canvas.getZoom(); // 50
editor.on('canvas:zoom', () => {
console.log('Canvas zoom updated:', editor.Canvas.getZoom());
});

### додати стилі до head

Додати стилі динамічно, (приклад з materialize):
const head = editor.Canvas.getDocument().head;
head.insertAdjacentHTML('beforeend', `<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">`);
head.insertAdjacentHTML('beforeend', `<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">`);
head.insertAdjacentHTML('beforeend', `<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>`);

### стиль для елемента Id.

var style = self.target.getStyle();
// style is empty even though the stylemanager shows the default background image from the class style rule
style['background-image'] ='url("' + newUrl + '")';
self.target.setStyle(style);

###

plugins: ["grapesjs-script-editor", "grapesjs-rulers"],

### component
#### Оnримати активний на canvas компонент
const component = (window as any).editor.getSelected();
if (component) {
#### Запустити подію на component
component.trigger("change:attributes:url");
#### Встановити атрибути 
component.setAttributes({ url: 'test', 'data-key': 'value' });
}
### Пошук компонентів
editor.getWrapper().find('div > .class');
editor.getWrapper().get('tagName');
const allImages = editor.getWrapper().findType('image');
### Пошук першого компонента
editor.getWrapper().closest('div.some-class');
const Section = editor.getWrapper().closestType('section');

### Встановити стилі
editor.getWrapper().setStyle({ color: 'red' });
const css = editor.Css;
#### додати 
css.addRules('.my-cls{ color: red } @media (max-width: 992px) { .my-cls{ color: darkred } }');
#### оновити
const rule = css.setRule('.class1.class2', { color: 'red' });
#### видалити
// Remove by CssRule
const toRemove = css.getRules('.my-cls');
css.remove(toRemove);
// Remove by selector
css.remove('.my-cls-2');
### Очистка всіх існуючих стилів у <head>:
Це видаляє всі існуючі теги <style> з <head> перед додаванням нових стилів.
const headComponent = editor.Canvas.getDocument().head;
const styleTags = headComponent.querySelectorAll('style');
styleTags.forEach(tag => tag.remove());
#### Видалення існуючих правил CSS з тими ж селекторами:
Це перевіряє, чи існують уже правила з тими ж селекторами, і видаляє їх перед додаванням нових.
````javascript
const existingRules = editor.CssComposer.getAll();
existingRules.forEach(rule => {
  if (styles.includes(rule.selectorsToString())) {
    editor.CssComposer.remove(rule);
  }
});
````
### видалити стилі
````javascript
const removeSpecificStyles = (editor, selector) => {
            editor.CssComposer.clear();
            const cssComposer = editor.CssComposer;

            // Шукаємо правило за селектором
            const rule = cssComposer.getRule(selector);

            if (rule) {
              cssComposer.remove(rule);
            }
          };
          removeSpecificStyles(editor, "body");
          removeSpecificStyles(editor, "*");
````
#### Очищення всіх стилів у редакторі
Щоб видалити всі стилі, ви можете використовувати метод 
editor.Css.clear()
#### Очищення стилів для конкретного компонента
const component = editor.getSelected(); // Отримуємо вибраний компонент
component.removeStyle(); // Видаляємо всі стилі компонента
#### Очищення стилів для сторінки 

#### Очищення стилів для певного класу або селектора
const selector = editor.Css.getRule('.my-class'); // Отримуємо правило для класу .my-class
if (selector) {
    editor.Css.remove(selector);
}
#### Очищення стилів із JSON-структури
editor.Css.clear(); // Очищення всіх існуючих стилів
editor.setStyle(data.css); // Встановлення нових стилів із JSON

### Створити
editor.getWrapper().set({
 tagName: 'span',
 attributes: { ... },
 removable: false,
});
### getJs
getJs()
// Розділити HTML, CSS і JavaScript
const htmlContent = code.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, ''); // Видаляє JavaScript
const jsContent = (code.match(/<script[^>]*>[\s\S]*?<\/script>/gi) || []).map(script => script.replace(/<\/?script[^>]*>/gi, '')).join('\n'); // Витягує JavaScript

### REFRESH
 // Оновлюємо канвас
  editor.render();
## cards
"[{\"name\":\"imgSrc\",\"type\":\"text\",\"tag\":\"img\"},
{\"name\":\"title\",\"type\":\"text\",\"tag\":\"span\"},
{\"name\":\"text\",\"type\":\"text\",\"tag\":\"p\"},
{\"name\":\"link\","type\":\"text\",\"tag\":\"a\"}]"

## posts
"[{\"name\":\"image\",\"type\":\"text\",\"tag\":\"img\"},
{\"name\":\"category\",\"type\":\"text\",\"tag\":\"span\"},
{\"name\":\"title\",\"type\":\"text\",\"tag\":\"p\"},
{\"name\":\"author\",\"type\":\"text\",\"tag\":\"p\"},
{\"name\":\"date\",\"type\":\"date\",\"tag\":\"p\"},
{\"name\":\"excerpt\",\"type\":\"text\",\"tag\":\"p\"},
{\"name\":\"link\",\"type\":\"text\",\"tag\":\"a\"}]" 


 